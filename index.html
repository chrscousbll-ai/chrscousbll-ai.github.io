<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Roadside Vegetation Mapper</title>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<style>
  html, body { height: 100%; margin: 0; }
  #map { height: 100%; width: 100%; }
  .toolbar {
    position: fixed; top: 8px; left: 50%; transform: translateX(-50%);
    display: flex; flex-wrap: wrap; gap: 8px; z-index: 1000;
    background: rgba(255,255,255,0.95); padding: 8px; border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    max-width: 960px;
  }
  .toolbar button {
    font-size: 16px; padding: 10px 12px; border: 0; border-radius: 10px;
    cursor: pointer; min-width: 88px; font-weight: 600;
  }
  .toolbar button.active { outline: 3px solid #000; }
  .row { display: flex; gap: 8px; width: 100%; justify-content: center; }
  .pill { padding: 10px 14px; border-radius: 999px; background: #eee; }
  .status {
    position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.7); color: #fff; padding: 8px 12px; border-radius: 12px;
    z-index: 1000; font-family: system-ui, sans-serif; font-size: 14px;
  }
  .hidden { display: none; }
</style>
</head>
<body>
<div id="map"></div>

<div class="toolbar" role="toolbar" aria-label="Vegetation controls">
  <div class="row">
    <button data-cat="grass" style="background:#7CB342;">Grass</button>
    <button data-cat="brush" style="background:#8D6E63; color:#fff;">Brush</button>
    <button data-cat="small_trees" style="background:#43A047; color:#fff;">Small Trees</button>
    <button data-cat="large_trees" style="background:#1B5E20; color:#fff;">Large Trees</button>
    <button data-cat="invasive" style="background:#E53935; color:#fff;">Invasive</button>
    <button data-cat="clear" style="background:#90A4AE;">Clear</button>
    <button data-cat="unknown" style="background:#9E9E9E;">Unknown</button>
  </div>
  <div class="row">
    <button id="startBtn" class="pill" style="background:#4CAF50; color:#fff; min-width:110px;">Start</button>
    <button id="pauseBtn" class="pill" style="background:#FF9800; color:#fff; min-width:110px;">Pause</button>
    <button id="undoBtn" class="pill" style="background:#607D8B; color:#fff;">Undo point</button>
    <button id="exportBtn" class="pill" style="background:#3F51B5; color:#fff;">Export GeoJSON</button>
    <label class="pill" style="cursor:pointer;">
      Import GeoJSON
      <input id="importInput" type="file" accept=".geojson,application/geo+json,application/json" style="display:none;">
    </label>
  </div>
</div>

<div id="status" class="status hidden">Ready.</div>

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>
<script>
(function () {
  // --- Map setup ---
  const map = L.map('map', { zoomControl: false });
  L.control.zoom({ position: 'bottomright' }).addTo(map);
  const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 20, attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  // Try to center on current location initially
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude, longitude } = pos.coords;
        map.setView([latitude, longitude], 16);
      },
      () => map.setView([45, -93], 4),
      { enableHighAccuracy: true, timeout: 10000 }
    );
  } else {
    map.setView([45, -93], 4);
  }

  // --- Categories & colors ---
  const CAT_COLORS = {
    grass: '#7CB342',
    brush: '#8D6E63',
    small_trees: '#43A047',
    large_trees: '#1B5E20',
    invasive: '#E53935',
    clear: '#90A4AE',
    unknown: '#9E9E9E'
  };

  // --- State ---
  let tracking = false;
  let paused = false;
  let currentCategory = null;
  let currentSegment = null;
  let watchId = null;
  let lastPoint = null;

  // Array of { category, color, coords: [[lat,lng],...], tStart, tEnd, layer }
  const segments = [];

  // UI elements
  const buttons = Array.from(document.querySelectorAll('[data-cat]'));
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const undoBtn = document.getElementById('undoBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importInput = document.getElementById('importInput');
  const statusEl = document.getElementById('status');

  function setStatus(text, show=true) {
    statusEl.textContent = text;
    statusEl.classList.toggle('hidden', !show);
    if (show) setTimeout(() => statusEl.classList.add('hidden'), 2500);
  }

  function setActiveButton(cat) {
    buttons.forEach(b => b.classList.toggle('active', b.dataset.cat === cat));
  }

  function startTracking() {
    if (!navigator.geolocation) {
      setStatus('Geolocation not supported.', true);
      return;
    }
    if (watchId !== null) navigator.geolocation.clearWatch(watchId);

    tracking = true;
    paused = false;
    startBtn.textContent = 'Stop';
    startBtn.style.background = '#F44336';
    pauseBtn.textContent = 'Pause';
    pauseBtn.style.background = '#FF9800';

    watchId = navigator.geolocation.watchPosition(onPosition, onPositionError, {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 20000
    });
    setStatus('Tracking started.');
  }

  function stopTracking() {
    tracking = false;
    paused = false;
    if (watchId !== null) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
    startBtn.textContent = 'Start';
    startBtn.style.background = '#4CAF50';
    pauseBtn.textContent = 'Pause';
    pauseBtn.style.background = '#FF9800';
    endCurrentSegment();
    setStatus('Tracking stopped.');
  }

  function toggleStart() {
    if (tracking) stopTracking(); else startTracking();
  }

  function togglePause() {
    if (!tracking) return;
    paused = !paused;
    if (paused) {
      pauseBtn.textContent = 'Resume';
      pauseBtn.style.background = '#4CAF50';
      endCurrentSegment();
      setStatus('Paused.');
    } else {
      pauseBtn.textContent = 'Pause';
      pauseBtn.style.background = '#FF9800';
      setStatus('Resumed.');
    }
  }

  function onPositionError(err) {
    setStatus(`GPS error: ${err.message}`, true);
  }

  function beginSegment(cat) {
    endCurrentSegment();
    currentCategory = cat;
    setActiveButton(cat);
    const color = CAT_COLORS[cat] || '#000';
    const line = L.polyline([], { color, weight: 6, opacity: 0.95 }).addTo(map);
    currentSegment = {
      category: cat,
      color,
      coords: [],
      tStart: new Date().toISOString(),
      tEnd: null,
      layer: line
    };
    segments.push(currentSegment);
  }

  function endCurrentSegment() {
    if (currentSegment) {
      currentSegment.tEnd = new Date().toISOString();
      if (currentSegment.coords.length < 2) {
        // Too short; remove from map and array
        map.removeLayer(currentSegment.layer);
        segments.pop();
      }
      currentSegment = null;
    }
  }

  // Minimum distance (meters) to log next point to reduce GPS jitter
  const MIN_DIST_M = 5;

  function haversine(a, b) {
    const toRad = d => d * Math.PI / 180;
    const R = 6371000;
    const dLat = toRad(b.lat - a.lat);
    const dLng = toRad(b.lng - a.lng);
    const s =
      Math.sin(dLat/2)**2 +
      Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLng/2)**2;
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  function onPosition(pos) {
    if (!tracking || paused) return;
    const p = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    if (!lastPoint) lastPoint = p;

    const dist = haversine(lastPoint, p);
    if (dist < MIN_DIST_M) return; // skip tiny moves

    // Pan map toward current point (soft follow)
    map.panTo([p.lat, p.lng], { animate: true, duration: 0.5 });

    // if no active category yet, default to 'unknown'
    if (!currentSegment) beginSegment(currentCategory || 'unknown');

    // append point
    currentSegment.coords.push([p.lat, p.lng]);
    currentSegment.layer.addLatLng([p.lat, p.lng]);

    lastPoint = p;
  }

  // --- Button handlers ---
  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      const cat = btn.dataset.cat;
      if (!tracking || paused) {
        currentCategory = cat;
        setActiveButton(cat);
        setStatus(`Selected: ${readable(cat)} (will start on next move).`);
      } else {
        beginSegment(cat);
        setStatus(`Now mapping: ${readable(cat)}.`);
      }
    });
  });

  startBtn.addEventListener('click', toggleStart);
  pauseBtn.addEventListener('click', togglePause);

  undoBtn.addEventListener('click', () => {
    if (currentSegment && currentSegment.coords.length) {
      currentSegment.coords.pop();
      const latlngs = currentSegment.layer.getLatLngs();
      latlngs.pop();
      currentSegment.layer.setLatLngs(latlngs);
      setStatus('Last point removed.');
    } else {
      setStatus('Nothing to undo.');
    }
  });

  exportBtn.addEventListener('click', () => {
    endCurrentSegment(); // close any active segment
    const features = segments
      .filter(s => s.coords.length >= 2)
      .map(s => ({
        type: "Feature",
        geometry: { type: "LineString", coordinates: s.coords.map(([lat,lng]) => [lng, lat]) },
        properties: {
          category: s.category,
          color: s.color,
          time_start: s.tStart,
          time_end: s.tEnd
        }
      }));
    const fc = { type: "FeatureCollection", features };
    const blob = new Blob([JSON.stringify(fc, null, 2)], { type: "application/geo+json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `veg-roads-${new Date().toISOString().replace(/[:.]/g,'-')}.geojson`;
    a.click();
    URL.revokeObjectURL(url);
    setStatus('GeoJSON exported.');
  });

  importInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const text = await file.text();
    try {
      const data = JSON.parse(text);
      loadGeoJSON(data);
      setStatus('GeoJSON imported & displayed.');
    } catch (err) {
      setStatus('Import failed: invalid JSON.', true);
    } finally {
      importInput.value = '';
    }
  });

  function loadGeoJSON(geojson) {
    L.geoJSON(geojson, {
      style: f => ({
        color: f.properties?.color || '#000',
        weight: 6, opacity: 0.95
      })
    }).addTo(map);
    const layer = L.geoJSON(geojson);
    const b = layer.getBounds();
    if (b.isValid()) map.fitBounds(b, { padding: [30,30] });
  }

  function readable(cat) {
    return ({
      grass: 'Grass',
      brush: 'Brush',
      small_trees: 'Small Trees',
      large_trees: 'Large Trees',
      invasive: 'Invasive',
      clear: 'Clear',
      unknown: 'Unknown'
    })[cat] || cat;
  }

})();
</script>
</body>
</html>
